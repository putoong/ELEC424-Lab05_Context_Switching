Lab05: Context Switching
<Kai and Pu>

Part 1: 5

Q1. How many timers do you use in lab4? Is there any difference if you use 1 
    timer and 2 timers for scheduling? 
    Answer : We used two timers. ???

Q2. Suppose there are task1 and task2, task1 has higher priority than task2, by
    manual scheduling what will happen if task1 needs to be executed while task2
    is running?
    Answer : When task2 is running and task1 needs to cut in, task1 has to wait until task2 finishes. ???

    /* When task2 is running, it has its own stack and it has the control of all registers available. Therefore, if a switch is needed (task1 has higher priority than task2), its own stack as well as registers should be saved. After saving all context, task1 is loaded and get activated. It executes until it finishes. Then the OS will switch back to task1. */ 

Q3. What is MSP and PSP, what are they used for? 
	Answer : MSP stands for main stack pointer; PSP is for process stack pointer. MSP is used by operating system to keep track of its own stack in privilieged mode. All activities by OS are recorded in the stack by MSP. PSP is used by user process to keep track of information (local variables, input arguments when subroutine call happens, etc) generated by the user process in unprivileged mode.

Q4. What is SysTick and PendSV? 
	Answer : They are system interrupts whose priorities could be configured by the user.

Q5. What context contents are saved during a context switch, by hardware or by 
    software?
    Answer : In general, in a context switch from thread A to thread B, contents saved include all registers and the stack pointer of thread A. In cortex M3, hardware helps save registers from xPSR, PC, LR, r0 - r3 as well as r12; software should save registers from r4 - r11 as well as the PSP after all registers are stacked. 

Part 2: 2

Q6. Why? Why can't a C program conduct a context switch? 
	Answer : This is because C programs do not have access to system resources such as register files and stacks which we need to do context switch. When one C program runs, it returns to its caller program instead of switching to another program. Therefore, we have to manually manage the register files as well as the OS/user thread stack pointer for context switch. 

Q7. What are the potential problems to use SysTick to conduct context switching?
	Answer : ??
Part 3: 3

Q8. What are the advantages of PendSV over SysTick to invoke a context switching? 
	Answer : PendSV allows context switch to be more flexible. For example, when thread A is running and finishes. It goes into idle mode, PendSV allows thread A to notify the system of its finish. Then the system will switch context. However, using SysTick only allows context switch at a certain frequency, which is not flexible. Some system resources are wasted.

Q9. Think about how you can make the scheduling easier than manual scheduling by 
    doing a context switching? 
    Answer : In manual scheduling, we have to manually set the order of the tasks. Also, in manual scheduling, one task has to be done before the next task starts. However, in context switching, the operating system will take care of the tasks with certain priorities set by the user. Also, one task does not need to finish before the next task with higher priority coming in. 

Q10. What would you do to improve your code to add priorities for each tasks?
	Answer : In our case, we have TCB as a struct for task controling. Each task has one TCB which saves the stack pointer of the task. All TCBs are stored in an array. To include priorities in context switching, we can add priority to the TCB. Each time a context switch is needed, search for the task with highest priority in the TCB array. And execute that task. ???

Contribution

Indicate the percentage work contributed by each partner below (should add up to 100%). Needless to say, replace PARTNER1/2 with names.

<PARTNER1>: Kai Zhang 60%
<PARTNER2>: Pu Dong 40%